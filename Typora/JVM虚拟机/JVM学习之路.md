# 深入了解java虚拟机

## 第一章 认识java

### 1.Java技术体系

1. ​	Java程序设计语言
2. ​    Java虚拟机
3.    Class文件格式
4. ​    Java API 类库
5. ​    商业机构，开源社区的第三方Java 类库

### 2.sdk、jdk、jre的区别

1. SDK ( Software Development Kit  )

   ​	一般是软件工程为特定的软件包、软件框架、硬件平台、操作系统等建立软件应用时的开发工具的集合。

2. JDK ( Java Development Kit )

   ​	java程序设计语言、java虚拟机、java API类库这三部分成为JDK。JDK是支持java程序开发的最小环境

3. JRE  ( Java Runtime Environment )

   ​	java API类库中的Java SE API子集、Java虚拟机成为JRE。JRE是支持Java运行环境的标准环境

   ​	所以，普通用户在访问某些网站的时候，提示需要安装java运行环境只需要安装jre即可。而相关的开发人员想要进行java开发的话，就需要下载jdk。

4. jdk的开发版本号和jdk的发行版本号。自从jdk1.3以来主版本发布都会使用动物命名，而修正版本则以昆虫命名。jdk1.5,以后，公开的发行版本为 jdk 5，jdk 6...而对应的开发版本号为jdk 1.5，jdk 1.6 。所以当别人聊jdk 6的时候，你应该知道了他说的其实是jdk的发行版本号。

5. ![](C:\Users\罗蒙\AppData\Roaming\Typora\typora-user-images\image-20210411235502491.png)

### 3.Sun Hot Spot VM

1. 准确式内存管理 ( Exact Memory Management )

   虚拟机可以知道某个位置的数据具体是什么类型，譬如内存中有一个32位的整数123456，他到底是一个reference类型指向123456的内存地址，还是一个数值为123456的整数，虚拟机能分辨出来。

   这样才能在GC的时候准确判断堆上的数据是否还可能被使用，抛弃了以前的classic VM 使用的基于handler的对象查找方式，定位对象的少了一次间接的开销，提高了性能

2. 热点代码探测能力

### 4.JDK历史

1. jdk 1.0 。技术包括：java虚拟机、applet、awt 。
2. jdk1.1.内部类，反射、jar文件格式、jdbc、javabeans、rmi
3. jdk 1.2。拆分技术体系，分别为j2se（桌面级应用）,j2ee（企业级应用，crm）,j2me（移动应用） 。技术：EJB、 Java Plugin- in、Java IDL、Swing。第一次内置了JIT编译器。
4. jdk 1.3 类库改进。
5. jdk 1.4 。Java走向成熟的一个版本。新的技术特性：正则表达式、异常链、NIO、日志类、XML解析器、XSLT转换器等。
6. jdk 1.5 。语法上巨大改进，自动装箱、泛型、foreach、动态注解、枚举、可变长参数、遍历循环等。改进了内存模型。提供了java.util.concurrent 并发包。
7. jdk 1.6 。对虚拟机内部做了大量改进。
8. .jdk 1.7 。提供新的G1收集器、加强对非java语言的调用、语言级的模块化支持、升级类加载架构等。
9. .jdk 1.8 。新增lambda 表达式、提供函数式接口等。

## 第二章 java内存区域

### 1.运行时数据区

#### 程序计数器

​		线程私有，当前线程执行字节码的指示器，实现代码的流程控制，比如线程切换回来之后，要从之前地方继续执行

#### 虚拟机栈

​		线程私有的部分，用来存放局部变量表，操作数栈等等，生命周期和线程相同

​		java方法执行的内存模型，每个方法执行的时候都会创建一个栈帧，用来存放局部变量表，操作数栈，动态连接，方法出口等信息。

​		每个方法的调用直至完成，代表着一个栈帧在虚拟机栈中的入栈和出栈的过程

​		局部变量表存放的是基本数据类型(boolean、byte、short、int、float、double、long、char)、对象引用、returnAddress(指向了一条字节码指令的地址)

​		其中64位长度的long和double类型的数据会占用2个局部变量表空间（slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法所需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

​		在Java虚拟机规范中，对此区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出Stack OverflowError异常；如果虚拟机栈可以动态扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

#### 本地方法栈

​	   和虚拟机栈类似，只是虚拟机栈执行的是java的方法，本地方法栈执行的是Navtive方法 

​		Navtive方法一个java调用非java的接口，一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。

#### 堆

​		线程共享的区域，几乎所有的对象都在这里分配内存，也是垃圾收集器的主要场所

​		但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也就变得不那么绝对了。

​		如果堆中没有内存完成实例的分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

#### 方法区

​		线程共享的区域，用来存放类的信息，常量，静态变量，即时编译器的代码，是堆的一个逻辑部分

​		在JDK1.7发布的HotSpot中，已经把字符串常量池移除方法区了

#### 运行时常量池

​		运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放

​		运行时常量池有个重要特性是动态性，Java语言不要求常量一定只在编译期才能产生，也就是并非预置入class文件中常量池的内容才能进入方法区的运行时常量池，运行期间也有可能将新的常量放入池中，这种特性使用最多的是String类的intern()方法。

​		既然运行时常量池是方法区的一部分，自然受到方法区内存的限制。当常量池无法再申请到内存时会抛出outOfMemeryError异常。



## 第三章 JVM垃圾回收器

#### 1.概述

​	在java内存区域中，程序计数器，虚拟机栈，本地方法栈，3个区域随线程的生存而生存，栈中的栈帧随着方法的进入和退出而有条不絮地执行入栈和出栈的操作，分配多少内存在类结构确定是就已确定。所以这三个区域不需要考虑内存回收问题，线程结束了，内存也就回收了。

​	而Java堆和方法区则不一样，程序运行时才知道会创建哪些对象，线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是这部分内存。

​	因此在对堆进行内存回收前，需要确定，哪些对象还存活这，哪些对象也就死去？

#### 2.引用计数法

​	给对象添加一个计数器，每增加一个引用，计数器加1，当一个引用失效时，计数器减法1，当计数器为0时，表示对象不可能再被使用，可以被回收

​	优点：实现简单，效率高

​	缺点：无法解决对象间循环引用的问题

```
Object a = new Object();
Object b = new Object();
a=b;
b=a;
a=b=null; 
```

#### 3.可达性性分析算法

​	通过一系列的称为“GC Root” 的对象作为起始点，从这节点往下搜索，所走过的路径称为引用链（Reference Chain）,当对象到 GC Root 没有任何引用链时，表示对象不可能再被使用，可以被回收

![image-20210421222618682](C:\Users\罗蒙\AppData\Roaming\Typora\typora-user-images\image-20210421222618682.png)

在java语言中，GC Root的对象包括以下几种：

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
2. 方法区中静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中Navtive方法引用的对象

优点：更加精确，可以解决对象循环引用的问题

缺点：实现复杂，需要大量数据，消耗大量时间。分析过程需要GC停顿（引用关系不能发生变化），也就是停顿java执行线程

#### 3.引用

​	如何描述一些“食之无味，弃之可惜”的一类对象，希望能有这样一类对象，当内存空间足够时，不对它进行回收，当内存空间不足时，则抛弃这些对象。

​	在jdk1.2时，java对引用的概念进行了扩充，分为四类：强引用，软引用，弱引用，虚引用。

1. 强引用：Object a = new Object(),只要引用还在，就不会回收它
2. 软引用：描述有用但并非必须需的对象。在内存溢出异常之前，会对它进行二次回收。如果这次回收还没有足够的内存，则会抛出内存溢出的异常。SoftReference
3. 弱引用：非必需对象。只能活到下次垃圾回收之前
4. 虚引用：为一个对象设置虚引用，唯一的目的是在下次垃圾回收之前，能收到一个系统通知。

#### 4.对象生存还是死亡

​	宣告一个对象死亡，至少要经历两次标记

- ##### 	第一次标记

  如果对象在可达性分析算法后，没有到达GC Root 的引用链，则会进行第一次标记和第一次筛选

  筛选条件：判断对象是否有必要执行finalize()

  筛选结果：如果对象没有覆盖finalize()或者finalize()方法已被虚拟机调用过，则视为 ” 没有必要执行 “ 判定为可回收对象。

  ​				   如果有必要执行finalize(),则会被放入 F-Queue的队列，稍后在JVM自动建立、低优先级的Finalizer线程（可能多个线程）中触发这个方法

- #####     第二次标记

  GC对F-Queue中的对象进行二次标记

  如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。

- #####     finalize方法

  ​	finalize()是Object类的一个方法、一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用；

  　特别说明：并不提倡在程序中调用finalize()来进行自救。建议忘掉Java程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。

#### 5.回收方法区

​	永久带的垃圾收集主要分为两部分内容：废弃的常量和无用的类

- ##### 回收废弃常量

  　回收废弃常量与Java堆的回收类似。下面举个栗子说明

  　假如一个字符串“abc” 已经进入常量池中，但当前系统没有一个string对象是叫做abc的，也就是说，没有任何string对象的引用指向常量池中的abc常量，也没用其他地方引用这个字面量。如果这是发生内存回收，那么这个常量abc将会被清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

- ##### 回收无用类

  同时满足下面是哪个条件才能算是无用类

  1. 该类的所有实例都被回收
  2. 加载该类的ClassLoader已被回收
  3. 该类对应的 java.lang.class 对象没有任何地方引用

  虚拟机可以对同时满足这三个条件的类进行回收，但不是必须进行回收的。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。

